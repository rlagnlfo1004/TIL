엔티티 매니저에 대해 알기 위해선 영속성 컨텍스트에 대해 알아야 한다.

## **🧐 영속성 컨텍스트(Persistence Context) 란?**=

JPA에서 엔티티를 관리하기 위해서 만들어져있는 어떠한 공간

JPA에서 영속성 컨텍스트라는 DB와 시스템 간의 중개자 역할을 하는 개념을 사용하는 이유에 대해 알아보자

1. 캐싱(1차 캐시)
    
    ex) 데이터를 조회하는 기능을 처리할 때, DB에서 바로 조회하는 것이 아니라 영속성 컨텍스트에서 먼저 조회한다.
    
2. 영속된 엔티티의 동일성 보장 (1차 캐시의 연장선)
    
    ex) 영속되어 있는 동일한 id를 갖는 엔티티를 2번 조회한다고 가정해보자. 이 때, 조회된 각각의 객체는 동일한 주소값을 같는다. 즉, 정확히 동일한 객체인 것이다.
    
3. 쓰기 지연
    
    ex) 트랜잭션을 commit하는 순간에 영속성 컨텍스트의 엔티티에 대한 쿼리를 DB에 실행한다.
    
4. 변경 감지(Dirty checking)
    
    ex) 영속된 엔티티를 수정하면, 트랜잭션이 commit되는 순간 변경 쿼리가 DB에 실행된다.
    

영속성 컨텍스트는 엔티티를 영구 저장하는 환경으로 1차 캐싱, 쓰기 지연, 변경 감지를 통해 영속 로직을 효율적으로 할 수 있게 해준다. 이러한 효율적인 영속 로직 수행을 위해서 엔티티는 영속성 컨텍스트에 관리되어야 한다. 이런 작업을 도와주는 것이 바로 엔티티 매니저이다. 엔티티 매니저는 엔티티의 상태를 변경하고, 영속성 컨텍스트와 상호작용함으로써 영속 로직을 수행하는 역할을 가지고 있다.
<br></br>

## **🧐 EntityManager란?**

JPA를 사용하기 위해서는 Database 구조와 맵핑된 JPA Entity 들을 먼저 생성하게 된다. 모든 JPA의 동작은 이 Entity들을 기준으로 작동한다. 이때, Entity들을 관리하는 역할을 하는 놈이 EntityManager이다.

Entity는 영속성 컨텍스트와 관련하여 4가지 상태(비영속, 영속, 준영속, 삭제)를 가질 수 있다. 엔티티 매니저는 persist, merge, remove, close 메서드를 이용하여 Entity의 상태를 변경할 수 있다. 또한, 엔티티 매니저는 영속성 컨텍스트의 1차 캐시로부터 엔티티를 조회할 수 있으며, 쓰기 지연 저장소에 있는 쿼리들을 flush하여 DB와 동기화시킬 수 있다.

JPA의 Entity는 영속성 컨텍스트를 기준으로 Entity가 어떻게 되어있냐? 라는 질문에 대응하는 상태를 갖는다.

- 비영속: 영속성 컨텍스트와 무관한 일반적인 Java 객체인 상태
- 영속: 영속성 컨텍스트에 주입 또는 관리되고 있는 경우
- 준영속: 영속화 되었다가 분리된 경우(또는 식별자는 있지만 영속성 컨텍스트에 없는 객체)
- 삭제: 영속성 컨텍스트에서 아예 삭제된 데이터

<br></br>
## **⚡️ EntityManager의 동작**

JPA의 경우, 한 요청당, 하나의 EntityManager를 사용한다. 

각 EntityManager들은 정해진 **영속성 컨텍스트**를 참조한다. 그리고 이렇게 만들어진 EntityManger로 데이터를 다루기 위해서는 가장먼저 **Entity가 “영속화”** 되어 있어야한다.

> 참고) 일반적으로는 EntityManager 한 개당 하나의 영속성 컨텍스트를 갖지만, 스프링에서는 공통된 영속성 컨텍스트 하나를 여러 EntityManager가 참조한다.
> 
<br></br>
좀 더 쉽게 알아보자, DB에 있던 데이터 또는 사용자가 넘긴 데이터를 Entity로 만든 후, EntityManager의 영속성 컨텍스트에서 들고 있겠다는 것이다. 

```ruby
1. (요청)
2. EntityManager 만들어짐
3. Entity들을 영속성 컨텍스트에 생성 -> Entity 영속화
4. EntityManager가 영속성 컨텍스트를 기반으로 요청 처리(C, R, U, D)
```
<br></br>
## **⚡️트랜잭션 commit과 flush() 메서드**

EntityManager의 `.flush()` 메서드가 실행되게 되면 영속성 컨텍스트의 쓰기 지연 저장소에 존재하는 쿼리들을 DB에 수행하게 된다.

즉, `flush()`는 영속성 컨텍스트의 변경사항을 DB와 동기화하는 것이라고 볼 수 있다.

그렇다고, `.flush()`를 실행시켰다고 수행된 쿼리가 commit되는 것은 아니고, commit을 직접해줘야한다.

단, EntityManager로 트랜잭션을 생성한 경우, commit을 하면 `.flush()` 메서드가 자동적으로 먼저 실행된다.
<br></br>

## **🧐Entity의 상태**

Entity의 상태에 대해 더 자세히 알아보자

```java
Member member = new Member("코딩");
```
비영속 상태는 엔티티 객체가 새로 생성되었지만, 아직 영속성 컨텍스트와 연관되지 않은 상태이다. 이 상태에서는 데이터베이스와 전혀 관련이 없으며, 엔티티 객체는 메모리 상에만 존재합니다.
<br></br>

```java
em.persist(member);
em.merge(detagedMember);
em.find(Member.class, 1L);
```
영속 상태는 엔티티 객체가 영속성 컨텍스트에 관리되고 있는 상태이다. 이 상태에서는 엔티티의 변경 사항이 자동으로 데이터베이스에 반영된다.
<br></br>

```java
em.detach(member);
em.clear();
em.close();
```

준영속 상태는 엔티티 객체가 한 번 영속성 컨텍스트에 의해 관리되었지만, 현재는 영속성 컨텍스트와 분리된 상태이다. 이 상태에서는 엔티티 객체의 변경 사항이 더 이상 데이터베이스에 반영되지 않는다. 영속성 컨텍스트 종료, 트랜잭션 종료 등으로도 준영속 상태로 전환된다.
<br></br>

```java
em.remove(member);
```

삭제 상태는 엔티티 객체가 영속성 컨텍스트에서 제거된 상태이다. 이 상태에서는 엔티티 객체가 데이터베이스에서 삭제된다.
<br></br>

## **📚 참고**

[[JPA] 영속성 컨텍스트 이해하기 (w. Entity manager)](https://velog.io/@juhyeon1114/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-w.-Entity-manager)

[[10분 테코톡] 산초의 영속성 컨텍스트와 EntityManager](https://www.youtube.com/watch?v=c4rDrirE7Bc)